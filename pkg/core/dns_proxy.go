package core

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/miekg/dns"
)

const resolverDir = "/etc/resolver"

// DNSProxy handles DNS queries and implements dynamic routing
type DNSProxy struct {
	config           *Config
	getRouter        func() *Router
	server           *dns.Server
	mu               sync.RWMutex
	domains          map[string]bool
	createdResolvers []string
}

// NewDNSProxy creates a new DNS Proxy instance
func NewDNSProxy(config *Config, getRouter func() *Router) *DNSProxy {
	domains := make(map[string]bool)
	for _, d := range config.TetherDomains {
		domains[strings.ToLower(d)] = true
	}

	return &DNSProxy{
		config:    config,
		getRouter: getRouter,
		domains:   domains,
	}
}

// Start begins the DNS proxy server
func (p *DNSProxy) Start() error {
	if !p.config.DNSProxyEnabled {
		return nil
	}

	port := p.config.DNSProxyPort
	if port == 0 {
		port = 5454
	}

	addr := fmt.Sprintf("127.0.0.1:%d", port)
	p.server = &dns.Server{
		Addr: addr,
		Net:  "udp",
	}

	mux := dns.NewServeMux()
	mux.HandleFunc(".", p.handleDNSRequest)
	p.server.Handler = mux

	log.Printf("üì° DNS Proxy starting on %s...", addr)

	// Start server in background
	go func() {
		if err := p.server.ListenAndServe(); err != nil {
			log.Printf("‚ùå DNS Proxy failed: %v", err)
		}
	}()

	// Give the server a moment to start before setting up resolvers
	time.Sleep(100 * time.Millisecond)

	// Setup system resolvers
	if err := p.setupSystemResolvers(port); err != nil {
		log.Printf("‚ùå Failed to setup system resolvers: %v", err)
		// We continue anyway, but log the error clearly
	}

	return nil
}

// Stop stops the DNS proxy server
func (p *DNSProxy) Stop() error {
	// Clean up resolvers first
	if err := p.cleanupSystemResolvers(); err != nil {
		log.Printf("‚ùå Failed to cleanup system resolvers: %v", err)
	}

	if p.server != nil {
		log.Println("üõë Stopping DNS Proxy...")
		return p.server.Shutdown()
	}
	return nil
}

// setupSystemResolvers creates resolver files for macOS
func (p *DNSProxy) setupSystemResolvers(port int) error {
	// Check if we are running as root
	if os.Geteuid() != 0 {
		return fmt.Errorf("root privileges required to manage /etc/resolver")
	}

	// Ensure /etc/resolver exists
	if err := os.MkdirAll(resolverDir, 0755); err != nil {
		return fmt.Errorf("failed to create resolver directory: %w", err)
	}

	content := fmt.Sprintf("# Generated by Network Router\nnameserver 127.0.0.1\nport %d\n", port)

	p.createdResolvers = make([]string, 0)

	// Create resolver file for each domain
	// We iterate over the map keys (which include both "example.com" and "*.example.com")
	for domain := range p.domains {
		// Clean domain name for filename (remove leading *.)
		cleanDomain := strings.TrimPrefix(domain, "*.")
		cleanDomain = strings.TrimPrefix(cleanDomain, ".")

		if cleanDomain == "" {
			continue
		}

		filename := filepath.Join(resolverDir, cleanDomain)
		if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
			log.Printf("‚ö†Ô∏è Failed to create resolver for %s: %v", cleanDomain, err)
			continue
		}

		log.Printf("‚úì Created system resolver for: %s", cleanDomain)
		p.createdResolvers = append(p.createdResolvers, cleanDomain)
	}

	// Force Flush DNS Cache (mDNSResponder)
	// We execute it but don't fail if it doesn't work perfectly
	/*
		cmd := exec.Command("killall", "-HUP", "mDNSResponder")
		if err := cmd.Run(); err != nil {
			log.Printf("‚ö†Ô∏è Failed to flush DNS cache: %v", err)
		}
	*/

	return nil
}

// cleanupSystemResolvers removes the created resolver files
func (p *DNSProxy) cleanupSystemResolvers() error {
	if len(p.createdResolvers) == 0 {
		return nil
	}

	log.Println("Cleaning up system resolvers...")
	for _, domain := range p.createdResolvers {
		filename := filepath.Join(resolverDir, domain)
		if err := os.Remove(filename); err != nil {
			log.Printf("‚ö†Ô∏è Failed to remove resolver for %s: %v", domain, err)
		}
	}

	p.createdResolvers = nil
	return nil
}

func (p *DNSProxy) handleDNSRequest(w dns.ResponseWriter, r *dns.Msg) {
	m := new(dns.Msg)
	m.SetReply(r)
	m.Compress = false

	if len(r.Question) == 0 {
		w.WriteMsg(m)
		return
	}

	question := r.Question[0]
	qName := strings.ToLower(question.Name)
	domain := strings.TrimSuffix(qName, ".")

	log.Printf("üîç DNS Proxy Received: [%s] Type: %s", domain, dns.TypeToString[question.Qtype])

	// Check if domain matches wildcard patterns
	matched := p.matchesTetherDomain(domain)

	if matched {
		log.Printf("üéØ Match found for %s! Resolving and adding dynamic route...", domain)

		// Use upstream to resolve
		resp, err := p.resolveUpstream(r)
		if err == nil {
			// Extract IPs and add routes
			p.processResponse(resp)
			w.WriteMsg(resp)
			return
		}
		log.Printf("‚ö†Ô∏è Upstream resolution failed for %s: %v", domain, err)
	}

	// Forward to upstream for everything else or if resolution failed
	log.Printf("‚è© DNS Forwarding: %s to upstream", domain)
	resp, err := p.resolveUpstream(r)
	if err == nil {
		w.WriteMsg(resp)
	} else {
		dns.HandleFailed(w, r)
	}
}

func (p *DNSProxy) matchesTetherDomain(domain string) bool {
	p.mu.RLock()
	defer p.mu.RUnlock()

	// Direct match
	if p.domains[domain] {
		return true
	}

	// Wildcard match
	for pattern := range p.domains {
		if strings.HasPrefix(pattern, "*.") {
			suffix := strings.TrimPrefix(pattern, "*") // keep the dot: e.g., ".googlevideo.com"
			if strings.HasSuffix(domain, suffix) || domain == strings.TrimPrefix(suffix, ".") {
				return true
			}
		}
	}

	return false
}

func (p *DNSProxy) resolveUpstream(m *dns.Msg) (*dns.Msg, error) {
	var upstreams []string

	if p.config.DNSUpstream != "" {
		upstreams = []string{p.config.DNSUpstream}
	} else {
		upstreams = p.getSystemDNS()
		if len(upstreams) == 0 {
			upstreams = []string{"8.8.8.8:53", "1.1.1.1:53"}
		}
	}

	c := new(dns.Client)
	c.Timeout = 2 * time.Second

	var lastErr error
	for _, upstream := range upstreams {
		resp, _, err := c.Exchange(m, upstream)
		if err == nil {
			return resp, nil
		}
		lastErr = err
		// Continue to next upstream on failure
	}

	return nil, lastErr
}

func (p *DNSProxy) getSystemDNS() []string {
	config, err := dns.ClientConfigFromFile("/etc/resolv.conf")
	if err != nil || len(config.Servers) == 0 {
		return nil
	}
	
	servers := make([]string, 0, len(config.Servers))
	for _, s := range config.Servers {
		servers = append(servers, s + ":" + config.Port)
	}
	return servers
}

func (p *DNSProxy) processResponse(resp *dns.Msg) {
	router := p.getRouter()
	if router == nil {
		log.Println("‚ö†Ô∏è DNS Proxy: Cannot add dynamic route, router is not initialized yet")
		return
	}

	for _, rr := range resp.Answer {
		if a, ok := rr.(*dns.A); ok {
			ip := a.A.String()
			if err := router.AddDynamicRoute(ip); err != nil {
				log.Printf("‚ùå Failed to add dynamic route for %s: %v", ip, err)
			}
		}
	}
}
